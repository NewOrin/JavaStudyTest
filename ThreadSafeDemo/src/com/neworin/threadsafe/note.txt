1，每个锁对象(JLS中叫monitor)都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，
阻塞队列存储了被阻塞的线程，当一个线程被唤醒(notify)后，才会进入到就绪队列，等待CPU的调度，
反之，当一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒，这个涉及到线程间的通信，下一篇博文会说明。
看我们的例子，当第一个线程执行输出方法时，获得同步锁，执行输出方法，恰好此时第二个线程也要执行输出方法，
但发现同步锁没有被释放，第二个线程就会进入就绪队列，等待锁被释放。一个线程执行互斥代码过程如下：

        1. 获得同步锁；

        2. 清空工作内存；

        3. 从主内存拷贝对象副本到工作内存；

        4. 执行代码(计算或者输出等)；

        5. 刷新主内存数据；

        6. 释放同步锁。

        所以，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性
        
2， volatile是第二种Java多线程同步的机制，根据JLS(Java LanguageSpecifications)的说法，
 一个变量可以被volatile修饰，在这种情况下内存模型(主内存和线程工作内存)确保所有线程可以看到一致的变量值。
